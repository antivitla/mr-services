# Интерфейс.draft.001

* [Добавить заметку](d2583dc0-332e-11e7-9ed5-af0531fedc19)
* [Редактирование узла и дерева](d2583dc1-332e-11e7-9ed5-af0531fedc19)
* [Удаление](d25864d0-332e-11e7-9ed5-af0531fedc19)

<!-- {"id":"6077ee45-386e-11e7-b322-bd492bfb44d5","date":"2017-05-14T06:27:09.455Z","type":"tree"}-->

* * *

# Добавить заметку

## `$ nuka add`

С бухты-барахты `$ nuka add`, откроется редактор временного файла, туда пишем заметку, сохраняем, закрываем, в диалоге подтверждения сохранения сохраняем в базу. Заметка не остаётся на диске, сразу "в шкаф", в базу. Хорошо для заметок "записал и забыл".

## `$ nuka add --content`

Длинная формальная версия `$ nuka add`

## `$ nuka add "Моя новая заметочка ультракороткая"`

Без всякого промежуточного редактора просто сохранит этот текст как новую заметку в базу.

И её бессмысленно длинная, но концептуально важная версия `$ nuka add --content "Моя заметочка ультракороткая`.

## `nuka sync --content "Идеи проектов.md"`

Когда мы начинаем **серию** заметок, и они должны какое-то время быть на виду, а не как в `nuka add` бесследно спрятаться в базе. Создаём файл и пишем их туда, отделяя их `\n\n* * *\n\n` (три звезды и пустая строка перед и после). Когда придёт время сохранить их в базу, делаем `$ nuka sync --content "Идеи проектов.md"`. Парсер сохранит каждую заметку в базу, присвоив дату и id. А затем перезапишет и ваш файл, вставив заметки но добавив к ним в Markdown-комментарии эти свойства (дата и id). Затем вы можете добавить ещё заметок в этот файл или редактировать старые. И при следующем `$ nuka sync --content "Идеи проектов.md"` он перезапишет все заметки, тем самым обновив старые и добавив новые.

Парсер узнаёт о том что заметку не надо добавлять как новую, а надо обновить старую, по наличию в Markdown-комментарии поля id. Поэтому не надо удалять эти комментарии если вам нужна связь данной заметки с её копией в базе. Они содержат в себе JSON объект свойств, например `<!-- {"date":"2017-05-01T12:58:53.508Z","id":"5da64c20-2eb4-11e7-89cf-517f28d315d2","excerpt":"Если есть только то что есть, и ты как его часть или..."} -->`

**В качестве имени файла для `--content` может быть glob-паттерн, например `$ nuka sync --content *.md` (все .md-файлы текущей директории) или даже `$ nuka sync --content **/*.md` - все файлы текущей директорий и во всех подпапках.**

ВАЖНО. При данной операции имена файлов и структура папок никак нигде не сохраняется, вы остаётесь просто с ворохом несортированых и негруппированных заметок. Следующий раздел как раз о структурах.

## Структуры 

Ворох заметок-идей и ворох заметок дневника нужно отделить от вороха заметок по документации проекта. Структура "Дневник" - это в сущности опять markdown-заметка, но со ссылками на уже конкретные заметки-записи дневника. Или структура "Идеи" - тоже заметка со ссылками на все заметки-идеи. Каждая заметка в базе - это markdown-файл. И структура тоже является заметкой, тоже в базе и тоже является markdown-файлом. Для базы это все есть заметки. Итого, если у вас 100 записей дневника и 100 идей, то, когда вы создадите структуры, у вас в базе будут 202 заметки, 2 из которых - заметки о структурах.

Пример заметки-структуры:

    ```
    # Идеи

    [Почистить башмаки](638a52d0-2eb4-11e7-89cf-517f28d315d2)
    [Купить палатку](987a52d0-2eb4-11e7-89cf-517f28d315d2)
    [Был в Новгороде, видел как...](123a52d0-2eb4-11e7-89cf-8977f28d315d2)
    ```

**Структуры теоретически могут ссылаться на другие структуры. Ведь они все обладают id и являются заметками с точки зрения парсера. Но на март 2017 пока я это не реализовал чтоб не усложнять. Каждая сложная структура полностью описывает всё своё дерево до ссылки на уже конкретные заметки.** 

В заметках о сложных структурах вложенность делается через подзаголовки:

    ```
    # Учение о бытии

    [С чего следует начинать...](123a52d0-2eb4-11e7-89cf-8977f28d315d2)
    [Общее подразделение бытия](234a52d0-2eb4-11e7-89cf-8977f28d315d2)

    ## Определённость
    [Бытие](345a52d0-2eb4-11e7-89cf-8977f28d315d2)
    [Наличное бытие](456a52d0-2eb4-11e7-89cf-8977f28d315d2)

    ## Величина
    ### Количество
    [Чистое количество](567a52d0-2eb4-11e7-89cf-8977f28d315d2)
    [Непрерывная и дискретная величина](678a52d0-2eb4-11e7-89cf-8977f28d315d2)
    [Ограничение количества](789a52d0-2eb4-11e7-89cf-8977f28d315d2)

    ## Мера
    [Специфическое количество](891a52d0-2eb4-11e7-89cf-8977f28d315d2)
    ```

Так как файл (он же как-то называется у вас) содержит заметки, он является натуральной формой простой структуры. Названием узла является название файла. А директория с файлами с заметками - натуральная форма сложной структуры. Названия директорий это названия промежуточных узлов. Поэтому:

## `$ nuka add --node Идеи.md` 

Добавить простую структуру - узел, aka тематические заметки. Парсер сохранит в базу все заметки внутри файла, а затем создаст заметку структуры, с заголовком "Идеи" и ссылками на все эти заметки.

## `$ nuka add --node **/*.md`

Считает все файлы по маске (все .md-файлы включая подпапки в данном случае), сохранит все заметки **и для каждого файла** создаст отдельную структуру-узел.

**Все сохранения всех команд происходят через диалог, можно что-то не сохранять, пропускать.**

Но это всё простые, "плоские" структуры. А как быть со сложными, с глубиной вложенности от двух и более? Здесь возникает концепт "рабочего дерева файлов", как в Git. Вся ваша текущая папка, фильтрованная или нет по маске, включая подпапки, и есть "рабочее дерево". И сложная структура сохраняется именно как слепок этого рабочего дерева. Для корневого узла дерева (как назвать ваше рабочее дерево) название неоткуда взять (есть только имена детей, в виде папок и файлов), это будет предложено и оно может быть произвольным. В дальнейшем можно задать по умолчанию имя рабочей структуры и другие параметры для удобства, через файлик `mr.json`, но про это поздее.

## `$ nuka add --node`

Предложит создать файл заметку-узел? В текущей папке. И файл соответствующих заметок. Как инициализация. И проставит айди этому узлу.

## `$ nuka add --node "Как я провёл лето"`

Создаст с готовым названием заметку-узел (без спрашивания). И файл соответствующий, для заметок. С уже вписанными айди.

## `$ nuka add --tree **/*.md`

Сохранит все файлы .md во всех подпапках (исключая bower_components и node_modules), а затем построит единое для всех них дерево. Названия узлов будут браться из названий директорий и файлов. Итого если у вас 4 директории и в них по 10 файлов в каждом из которых по 10 заметок и плюс в текущей директории 2 файла по 10 заметок, то в базе появится 2 * 10 + 4 * 10 * 10 = 420 заметок и плюс одна заметка-структура для всего этого безобразия, итого 421 заметка.

## `$ nuka add --tree`

Аналогичен предыдущему, просто автоматом соберёт именно .md-файлы и их структуру. Маска нужна если задавать какие-то ваши префиксы или зачем-то тырить например .js. Хотя может вы привыкли к .txt.

## `$ nuka add --tree Идеи.md`

Так можно сделать, но возможно это не совсем то что вы имели в виду. Предположим в файле 10 заметок. Парсер сохранит все 10 заметок, а затем построит общий узел "рабочее дерево", в котором будет один узел "Идеи", который олицетворяет файл:

    ```
    # Рабочее дерево (произвольно заданное вами название)
    ## Идеи
    [Написать статью по вёрстке](891a52d0-2eb4-11e7-89cf-8977f28d315d2)
    [Обновить сервис расчета размеров](123a52d0-2eb4-11e7-89cf-8977f28d315d2)
    [Соцсеть для верстальщиков должна...](234a52d0-2eb4-11e7-89cf-8977f28d315d2)
    ```

Возможно вы имели в виду `$ nuka add --node Идеи.md`, тогда структуры была бы логичней:

    ```
    # Идеи
    [Написать статью по вёрстке](891a52d0-2eb4-11e7-89cf-8977f28d315d2)
    [Обновить сервис расчета размеров](891a52d0-2eb4-11e7-89cf-8977f28d315d2)
    [Соцсеть для верстальщиков должна...](891a52d0-2eb4-11e7-89cf-8977f28d315d2)
    ```

Рабочее дерево - это идея объединения узлов, нескольких. Объединение куда-то в третье, их родителя. Поэтому через `$ nuka add --tree [маска]` всегда создаётся дополнительный - корневой - узел, даже если ребёнок один.

## `$ nuka add --tree "Документация сервиса заметок"`

Опять инициализация с заданным именем?

## Заметка, узел заметок, дерево узлов заметок

Заметка это атом структуры. Структура может ещё и не понадобится. Узел - это уже простейшая группировка атомов-заметок. По теме, по клиентам, по разделам. А дерево это уже группировка группировок, дерево директорий, структура книги и чего угодно. Это базовые комоненты позволяющие выстраивать любые взаимосвязи.

## Лайфхаки 

### `$ nuka add` 

1) В открывшемся редакторе можно забубенить несколько заметок, они все раздельно пропарсятся и сохранятся. 

2) Да туда можно и заметку-структуру вписать и тоже пропарсится и сохранится как надо. 

3) Если в заметке будет указан её айди, то старая перезапишется новой.

<!-- {"id":"d2583dc0-332e-11e7-9ed5-af0531fedc19","date":"2017-05-03T16:43:29.306Z"}-->

* * *

# Редактирование узла и дерева

Но если в случае заметок, после редактировани, можно запустить `$ nuka sync`, то нет способа указать синхронизировать узел или дерево, потому что некуда писать JSON-свойства с id. Для узла сам файл является узлом, его содержимое отдано заметкам, а где же взять место для самой заметки-узла? В узле хранится дата создания, айди и потенциально другая информация - много всего.

Так как все они markdown-заметки, то и узел и дерево можно редактировать выведя их в файл. И там заменить заголовки, перераспределить группировки заметок.

## `$ nuka sync --node "Идеи проектов.md"`

Берёт файл "Идеи проектов.md", сохраняет все заметки, создает с диалогом подтверждения дополнительную заметку-узел "Идеи проектов". Затем перезаписывает исходный файл "Идеи проектов.md" заметками но с расставленными JSON-свойствами. А далее **создаёт файл "Идеи проектов.node.md** куда вписывает заметку-узел. При редактировании "Идеи проектов.node.md" (скажем выкинуть какие-то заметки) и последующем запуске `$ nuka sync --node "Идеи проектов.md"` парсер 1) сначала прочитает все заметки в файле заметок "Идеи проектов.md" обновив или создав новые в базе, затем 2) попытается прочитать файл узла "Идеи проектов.node.md". В случае успеха он 3) перезапишет ваш файл заметок заметками из базы, но только теми, которые были указаны в файле узла. 

**Работать будет и маска файлов `**/*.md` - в этом случае парсер будет искать файлы узлов с такими же именами что и файлы заметок но с суффиксом ".node".**

ВАЖНО. Единственный способ сказать базе обновить именно данную структуру - это существование рядом с файлом заметок файла узла. Если его удалить, то `$ nuka sync --node` создаст новый узел-заметку в базе. Дубликат фактически. Иногда это желаемое как раз поведение.

ВАЖНО. Так как файл узла - такая же заметка с JSON свойствами в комментариях - не удаляйте эти комментарии. Если их не будет, это равнозначно созданию новой структуры, опять дубликата. На самом деле важно чтоб был id. С другой стороны, для копошения в кишках можно принудительно изменить дату, но это можно делать попроще, но об этом позже.

## `$ nuka sync --tree **/*.md`

Это самая "большая" команда, работает аналогично git checkout.

База сначала пытается пропарсить и сохранить все найденные по маске заметки во всех файлах. Затем она строит дерево беря структуру директорий и имена файлов за модель, спрашивает у вас произвольное название этой структуры и сохраняет заметку о дереве. А затем создаёт в вашей директории файл с заметкой о структуре. Скажем назвали мы наше рабочее дерево заметок "Документация сервиса заметок". Команда в итоге создаст файл "Документация сервиса заметок.tree.md" в текущей директории.

И его можно редактировать, изменяя структуру. Следующий запуск `$ nuka sync --tree` заменит старую структуру файлов на новую.

ВАЖНО. Единственная связь файла дерева в вашей папке и дерева в базе - id записанный внутри него. Пока он есть, изменение имени файла дерева, например, заменит название структуры. И будет работать замена дерева папок и файлов. Но как только он исчезнет - то будет создано новое дерево в базе. Скорей всего это нежелательно, это будет дубликат. Поэтому не удаляйте без нужды JSON-объект из файла.

ВАЖНО. При синхронизации дерева по сути не имеет значение название файла, потому что он и так всего один может быть для данной директории. Первый попавшийся файл оканчивающийся на ".tree.md" будет расценен как файл текущего рабочего дерева. Поэтому 

## `$ nuka sync --tree "Документация сервиса заметок.tree.md"`

На случай если у вас тут лежит несколько файлов заметок-деревьев, синхронизировать по одному из них.

## `$ nuka sync --tree`

Аналогичен вызовы с маской - но загребёт все файлы ".md" сам автоматически. В качестве заметки-дерева будет использовать первый попавшийся ".tree.md" в текущей директории. Если у вас их там несколько, выбор непредсказуем.

## Лайфхаки редактирования узлов и деревьев

Если вам нужно просто обновить, отредактировать заметку-узел, вы имеете этот файл - то можно воспользоваться тем же самым `$ nuka sync --content "Идеи проектов.md"`, где "Идеи проектов.md" это файл узла или дерева. Какая разница - это та же заметка с id. Другое дело что только этим она и ограничится. Не обновит файл с самими заметками по данной структуре (или дерево файлов с заметками). Это иногда нежелательно.

## Интересные и неожиданные кейсы

Предположим у вас куча файлов заметок. Вы сделал sync --node и получили ещё пачку файлов заметок-узлов. Внести изменения и в заметку-узел и в сами заметки. Так вот, запустив теперь sync --content - то синхронизуется только контент, только заметки. Если вы в файлах узлов вносили изменения - удаляли заметки или добавили новых, то в соответствующих файлах с заметками их кол-во не изменится, там останутся те что и были, обновлённые. Потому что sync --content не следит за содержанием узлов. За этим следит sync --node. 

Ну и аналогично sync --tree. Если напустить sync --content на файлы, которые были синхронизированы sync --tree, то ни дерево файлов, ни кол-ва заметок и их распределение не изменится. 

Далее, а что будет если напустить sync --node на то, что было ранее sync --tree? Так как файл узла у нас скорей всего будет один (это корневой файл дерева), а самих файлов заметок много в подпапках, он насоздаёт на каждый файл новый узел, создаст новые файлы узлов. При этом файл дерева он проинтерпретирует как файл узла, создаст соотв. файл заметок и влепит соответствующие этому узлу заметки туда. Не совсем желательно, так что будьте осторожны. Впрочем плата за это - файлы узлов ненужные в базе. Ничего тут не удаляется и не изменяется - скорей замусоривается. Файл дерева останется как был, заметки останутся как были. Но прибавится мусора.

<!-- {"id":"d2583dc1-332e-11e7-9ed5-af0531fedc19","date":"2017-05-03T16:43:29.306Z"}-->

* * *

# Удаление

## `$ nuka delete --content [id]`

Удалить из базы заметку, зная её id. Не сильно эффективно, но можно. Id заметки после первой синхронизации хранится рядом с ней внутри файла в JSON объекте заметки.

ВАЖНО. Дерево-заметка и узел-заметка - это такие же заметки. Поэтому через именно эту команду можно удалить само дерево, не трогая сами заметки, на которые ссылаются узлы дерева. И то же с узлом. Когда нужно просто удалить лишнюю структуру (скажем по-другому решили организовать заметки а старая совсем не нужна или копия случайно), без удаления самих заметок. В самом деле, информация о структуре хранится в единственном месте - в файле структуры, поэтому всё что нужно удалить - это тупо этот файл.

## `$ nuka delete --content "Дневник.md"`

Залезет в файл, если там найдет id заметок в JSON объекте, (если это выведенные `$ nuka sync` командой файлы, то они там будут), удалит соответствующие заметки из базы.

## `$ nuka delete --content *.md`

Залезет во все файлы по маске и удалит что найдёт.

**Если у вас также выведен файл заметки-узла или заметки-дерева, то так как он тоже .md-файл и так как там тоже есть id - то этой командой эти заметки-узлы и заметки-деревья сами по себе тоже удалятся из базы, если попадут под маску и будут внутри себя содержать id. Эта команда-компаньон `$ nuka sync`, потому что в её результате эти файлы как раз и появляются. И если ничего не трогать, то эта команда удалит и узлы и деревья, ибо они сами в первую очередь тоже контент-заметки.**

ВАЖНО. id, которые команда ищет - в JSON-файле. То есть если маска файлов зацепит заметку-узел или заметку-дерево с ссылками на другие заметки в базе, то она не тронет эти ссылки, а удалит саму заметку-узел или заметку-дерево. Для этой команды ссылок не существует, для всё лишь заметка. И сами файлы она не удаляет. Ссылки умеет удалять следующая команда

## `$ nuka delete --content`

## `$ nuka delete --content [id]`

## `$ nuka delete --content "Идеи проектов.md"`

## `$ nuka delete --content *.md`

## `$ nuka delete --node`

## `$ nuka delete --node [id]` идентично --content [id]

## `$ nuka delete --node "Идеи проектов.md"`

## `$ nuka delete --node *.md`

## `$ nuka delete --tree` берет текущее рабочее дерево (дефолтная маска)

## `$ nuka delete --tree [id]`

## `$ nuka delete --tree "Документация сервиса заметок.md"` берет в качестве плана удаления данную заметку-узел или заметку-дерево

## `$ nuka delete --tree **/*.md` берет текущее рабочее дерево по маске

nuka add content notes.md > notes-node.md

вставить user-generated парсинг в md.parse и развязать тем самым с treenode

<!-- {"id":"d25864d0-332e-11e7-9ed5-af0531fedc19","date":"2017-05-03T16:43:29.306Z"}-->